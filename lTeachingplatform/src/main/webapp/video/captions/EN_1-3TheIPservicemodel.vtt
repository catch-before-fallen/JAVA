WEBVTT
0
00:00:00.060 --> 00:00:04.940
Now that you've learned about the four layer Internet model. we're going to focus on the network layer.

1
00:00:05.160 --> 00:00:07.240
This is the most important layer of the Internet.

2
00:00:07.400 --> 00:00:08.070
In fact. to many people.

3
00:00:08.160 --> 00:00:15.400
it is the Internet. Whenever we use the Internet. we were required to use the Internet protocol to send and receive our packets.

4
00:00:16.080 --> 00:00:19.550
You remember that we say that each layer provides a service to the layer

5
00:00:19.940 --> 00:00:25.360
above. In order to correctly use a layer. we need a good understanding of the service that it provides.

6
00:00:25.380 --> 00:00:30.260
Therefore. in this video. I'm going to walk through the service provided by the Internet protocol.

7
00:00:31.460 --> 00:00:34.740
IP Datagrams consist of a header and some data.

8
00:00:35.280 --> 00:00:40.620
When the transport layer has data to send it. hands a transport segment to the network layer.

9
00:00:40.780 --> 00:00:47.340
Below. the network layer puts the transport segment inside a new IP datagram that it creates.

10
00:00:47.770 --> 00:00:57.580
Ip's job is to deliver the datagram to the other end of the Internet. but 1st the IP datagram has to make make it over the 1st link to the 1st router.

11
00:00:58.460 --> 00:01:06.860
So IP sends the diagram to the link layer that puts it inside a link frame. such as an ethernet packet. and then chips it off to the 1st router.

12
00:01:07.340 --> 00:01:11.580
The IP service can be characterized by four properties listed here.

13
00:01:12.290 --> 00:01:14.930
It sends datagrams from end host to end host.

14
00:01:15.110 --> 00:01:18.210
It is unreliable. but makes a best effort to deliver the datagrams.

15
00:01:18.600 --> 00:01:22.180
The network maintains no PERU state associated with the datagrams.

16
00:01:22.380 --> 00:01:30.130
Let's take a look at each one of these. in turn. as listed in the table 1st IP is a datagram service.

17
00:01:30.130 --> 00:01:36.270
When we ask IP to send some data for us. it creates a datagram and puts our data inside.

18
00:01:36.510 --> 00:01:42.440
The datagram is a packet that is routed individually through the network based on the information in its header.

19
00:01:42.600 --> 00:01:45.140
In other words. the datagram itself contained.

20
00:01:45.300 --> 00:01:53.150
The header contains the IP address of the destination. which we abbreviate here as IPDA. for ip destination address.

21
00:01:53.530 --> 00:01:57.710
And the affording decision decision at each router is based on this IPDA.

22
00:01:58.800 --> 00:02:08.040
The ladygram header also contains an IP source address. or ipsay. saying where the packet came from. so the receiver knows where to send any response.

23
00:02:09.540 --> 00:02:17.380
Datagrams are routed hot by hot. through the network. from one router to the next. all the way from the IP source address to the IP destination address.

24
00:02:17.930 --> 00:02:26.150
We'll learn more about how routers work later. but for now. it's enough to know that each router contains a affording table that tells it where to send packets next.

25
00:02:26.410 --> 00:02:30.870
After it matches a given destination address. the router doesn't know the whole path.

26
00:02:31.090 --> 00:02:46.880
It simply uses the destination address to index into its own fording table so that it can forward the packet to the next top along the path towards its final destination. hot by pop. step by step. the packet makes its way from the source to the destination using only the destination address.

27
00:02:47.040 --> 00:02:56.640
In the datagram. you'll often hear the analogy made between how IP datagrams are routed and how letters are built routed by the postal service.

28
00:02:56.640 --> 00:03:09.210
It's a good analogy. In the postal service. we put a letter into the mailbox with the address of the destination. and the letter is routed invisiblely to us. hot by hot. from sorting office to sorting office until it reaches its destination.

29
00:03:09.470 --> 00:03:15.980
Neither sender or the receiver. No or need to know the path taken by the letters in the postal service or by datagrams.

30
00:03:16.140 --> 00:03:22.080
In the Internet. The IP service model provides a service which includes the routing to the destination.

31
00:03:26.440 --> 00:03:32.740
The 2nd aspect of the IP service model. and perhaps most surprisingly. is IP is unreliable.

32
00:03:33.060 --> 00:03:37.100
IP makes no promise that packets will be delivered to the destination.

33
00:03:37.360 --> 00:03:40.820
They could be delivered late out of sequence or never delivered at all.

34
00:03:41.140 --> 00:03:44.480
It's possible that a packet will be duplicated along the way. e.g.

35
00:03:44.640 --> 00:03:58.080
by a misbehaving router. The key thing to remember is that IP is unreliable and makes no guarantees. but it won't drop datagrams arbitrarily just because it feels like it.

36
00:03:58.240 --> 00:04:00.060
That's if you believe networks have feelings.

37
00:04:00.360 --> 00:04:06.080
IP does make the promise to only drop datagrams if necessary. e.g.

38
00:04:06.480 --> 00:04:11.580
the packet cue in a router might fill up because of congestion. forcing the router to drop the next arriving packet.

39
00:04:11.620 --> 00:04:13.720
IP won't make any attempt to resend the data.

40
00:04:13.780 --> 00:04:17.020
In fact. IB doesn't even tell the source that the packet was dropped.

41
00:04:17.830 --> 00:04:24.750
Similarly. a faulty routing table might cause a packet to be sent to the wrong destination or cause a packet to be duplicated by mistake.

42
00:04:25.100 --> 00:04:30.240
IP doesn't make any promises that these errors won't happen. nor does it detect them when they do.

43
00:04:30.540 --> 00:04:35.650
But IP does make the promise to only make these errors and drop packets when necessary.

44
00:04:37.130 --> 00:04:42.120
In fact. the IP datagram service is very much like the basic personal service.

45
00:04:42.280 --> 00:04:52.140
The basic postal service. makes no promise that our letters will be delivered on time. or that. if we send two or three letters back to back on consecutive days. that they'll be received in the order they were sent.

46
00:04:52.520 --> 00:04:58.740
And it makes no promise they'll be delivered at all. unless we pay for a more expensive inter end service to guarantee delivery.

47
00:04:59.660 --> 00:05:00.320
Really. when

48
00:05:00.440 --> 00:05:04.300
it comes down to it. IP is an extremely simple. minimal service.

49
00:05:04.480 --> 00:05:07.610
It maintains no state at all related to a communication.

50
00:05:07.770 --> 00:05:10.390
We say that a communication service is connectionless

51
00:05:10.550 --> 00:05:14.610
because it doesn't start by establishing some end to end state

52
00:05:14.750 --> 00:05:26.910
associated with a communication. In other words. when we make a Skype call lasting several minutes and consisting of many IP diagrams. the IP layer maintains no knowledge of the call and simply routes each datagram

53
00:05:27.130 --> 00:05:30.250
individually and independently of all the others.

54
00:05:34.470 --> 00:05:37.630
You might be wondering why the IP service is so simple.

55
00:05:37.730 --> 00:05:41.170
After all. it is the foundation of the entire Internet.

56
00:05:41.330 --> 00:05:46.090
Every communication over the Internet users must use the IP service.

57
00:05:46.530 --> 00:05:51.730
Given how important the Internet is. wouldn't it have been better to make IP reliable?

58
00:05:52.050 --> 00:05:57.330
After all. we did say that most applications want a reliable. bite communication service.

59
00:05:58.340 --> 00:06:02.980
There are several reasons the IP service model was designed to be so simple.

60
00:06:04.580 --> 00:06:11.640
1st. to keep the network simple. dumb and mineral. faster. more streamlined and lower cost to build and maintain.

61
00:06:12.720 --> 00:06:22.490
It was believed that if the network is kept simple with very few features and requirements. then packets could be delivered very quickly and at low cost to the destination.

62
00:06:22.750 --> 00:06:33.310
The thinking was that a simple network could be made to run very fast using dedicated hardware. and given that the network is implemented by a large number of a routers scattered throughout the network. across the world.

63
00:06:33.470 --> 00:06:43.170
If they could be kept simple. then they are more likely to be reliable. more affordable. easier to maintain. and will need to be upgraded less often.

64
00:06:45.050 --> 00:06:47.330
2nd is the end to end principle.

65
00:06:47.520 --> 00:06:57.140
The Endoend Principle states that where possible. implement features in the end hosts in the design of communication systems such as the Internet.

66
00:06:57.300 --> 00:07:04.920
There's a well known principle called the end when principle that says. if you can correctly implement features at the end points. then you should.

67
00:07:05.760 --> 00:07:16.800
We'll study the end to end principle in more depth in later videos. but the basic idea is to place as much intelligence as possible at the endpoints. in our case. the source and destination computers.

68
00:07:17.220 --> 00:07:29.910
This can have several advantages. such as making sure the feature is implemented correctly for the application. and it's easier to evolve and improve a feature if it's implemented in software on end computers. rather than baked into the hardware of the Internet.

69
00:07:30.630 --> 00:07:39.420
In the case of the Internet. it was decided that features such as reliable communications and controlling congestion should be done at the end points by the source and destination.

70
00:07:39.580 --> 00:07:41.360
Computers are not by the network.

71
00:07:41.800 --> 00:07:55.720
At the time. it was quite a radical suggestion and very. very different design choice from the telephone system. the largest existing network at the time. which was originally built on the idea of simple handsets and a complicated. feature rich network of telephone switches.

72
00:07:56.480 --> 00:08:03.090
In later videos. will be studying the end to end principle as one of the important architectural principles of communication systems.

73
00:08:03.250 --> 00:08:06.370
We'll see many examples of the end to end principle in action. e.g.

74
00:08:06.530 --> 00:08:14.510
when we study the transport layer. we'll see how the end hosts build a reliable communication service over the unreliable IP network service.

75
00:08:19.430 --> 00:08:26.300
A simple I-P service also allows a variety of reliable or unreliable services to be built on top.

76
00:08:27.420 --> 00:08:37.150
If I-P was reliable. in other words. if any missing packets were re transmitted automatically. then it would not be ideal for some services. e.g.

77
00:08:37.310 --> 00:08:45.600
in real real time applications. like a video chat. there might be no point in re transmitting lost data. because it might arrive too late to be useful.

78
00:08:46.560 --> 00:08:52.260
Instead. the application might choose to show a few blank pixels or use the pixels from the frame before.

79
00:08:52.820 --> 00:08:58.980
By not providing any reliability guarantees. IP lets the application choose the reliability service it needs.

80
00:09:03.630 --> 00:09:06.270
Finally. IP works over any link layer.

81
00:09:06.430 --> 00:09:09.330
IP makes very few assumptions about the link layer.

82
00:09:10.290 --> 00:09:18.490
IP makes very little expectation at all of the link layer below the link could be wired or wireless. and requires no re transmission or control of congestion.

83
00:09:18.640 --> 00:09:25.120
Some people have said IP is so simple to make. so few assumptions about the underlying licklayer. that you could run IP over carrier pigeons.

84
00:09:25.320 --> 00:09:28.220
In fact. there's even an Internet stander telling he had to do it.

85
00:09:29.100 --> 00:09:36.650
Making IP run over any link layer made sense. because the Internet was created specifically to interconnect existing networks.

86
00:09:36.810 --> 00:09:38.630
In fact. that's why it was called the Internet.

87
00:09:43.350 --> 00:09:51.530
In addition to the basic. unreliable. best effort. connectionless diagram service. IP also provides a few other carefully chosen services.

88
00:09:51.770 --> 00:10:03.440
The designers of IP tried very hard to find a balance between providing the bare minimum needed to make communications work. while not providing such a bare bone service that it doesn't really work at all.

89
00:10:04.350 --> 00:10:07.590
I'm going to describe five features here. and you'll learn

90
00:10:07.850 --> 00:10:10.010
about each one of these features in later videos.

91
00:10:10.170 --> 00:10:17.350
So I won't go into a lot of details here. but I will briefly describe each one so you can understand the scope of the complete IP service.

92
00:10:18.110 --> 00:10:18.430
1st

93
00:10:18.750 --> 00:10:21.950
IP tries to prevent packets from looping forever.

94
00:10:22.160 --> 00:10:23.110
Because IP routers

95
00:10:23.120 --> 00:10:31.720
forward packets hot By hop across the Internet. it is possible for the folding table and a router to be wrong. causing a park packet to start looping round and around.

96
00:10:32.020 --> 00:10:40.460
following the same path. This is most likely to happen when the folding tables are changing. and they temporarily get into an inconsistent state.

97
00:10:41.430 --> 00:10:51.800
Rather than try to prevent loops from ever happening. which would take a lot of complexity. IP uses a very simple mechanism to catch and then delete packets that appear to be stuck in a loop.

98
00:10:52.320 --> 00:10:57.200
To do this. IP simply adds a hop count field in the header of every day togram.

99
00:10:57.590 --> 00:11:00.910
It's called The Time to Live. or TTL Field.

100
00:11:01.150 --> 00:11:07.320
It starts out at a number like 128. and then it's decremented by every router it passes through.

101
00:11:07.480 --> 00:11:13.020
If it reaches zero. I be concludes that it must be stuck in a loop. and the rounder drops the datagram.

102
00:11:13.260 --> 00:11:16.020
It's a simple mechanism typical of IP.

103
00:11:16.350 --> 00:11:18.650
It doesn't guarantee that loops won't happen.

104
00:11:18.910 --> 00:11:23.570
It just tries to limit the damage caused by a flood of endlessly looping packets in the network.

105
00:11:27.330 --> 00:11:30.250
IP will fragment packets if they are too long.

106
00:11:32.120 --> 00:11:34.420
IPS designed to run over any kind of link.

107
00:11:34.580 --> 00:11:37.680
Most links have a limit on the size of the packets that they can carry.

108
00:11:37.940 --> 00:11:41.760
E.G. ETHANEC can only carry packets shorter than 15 hundred bites.

109
00:11:42.560 --> 00:11:50.260
If an application has more than 15 hundred bites to send. has to be broken into 15 hundred bite pieces before sending in an IP datagram.

110
00:11:50.460 --> 00:11:59.860
Now. along the path towards the destination. a 15 hundred bite datagram might need to go over a link that can only carry smaller packets. let's say a thousand bites long.

111
00:12:00.340 --> 00:12:05.420
The router connecting the two links will fragment the data into two smaller datagrams.

112
00:12:06.470 --> 00:12:19.260
IP provides some headfields that will see in a minute to help the route of fragment the datagram. and two self contained IP datagrams. while providing the information the in host needs to correctly reassemble the data again.

113
00:12:21.420 --> 00:12:27.780
IP uses a head of chicksum to reduce the chances of delivering a datagram to the wrong destination.

114
00:12:29.140 --> 00:12:35.480
I be include to check some field in the datagram header to try and make sure that datagrams are delivered to the right location.

115
00:12:36.120 --> 00:12:43.280
It could be quite a security problem if packets are accidentally and frequently sent to the wrong place because of a mistake by a router along the way.

116
00:12:45.210 --> 00:12:49.210
4th There are two versions of IPN used today.

117
00:12:49.490 --> 00:12:53.450
IPV four. which is used today by over 90% of end hosts.

118
00:12:53.640 --> 00:12:59.880
It uses the 32 bit addresses you're probably familiar with. because we're running out of IP FOUR addresses.

119
00:13:00.080 --> 00:13:05.900
The Internet is in a gradual transition to IPV six. which uses 128 bit addresses.

120
00:13:06.080 --> 00:13:11.640
Instead. you'll be learning about the details of IPV four and IPV six in later videos.

121
00:13:12.240 --> 00:13:17.980
Finally. IP allows new fields to be added to the datagram header practice.

122
00:13:18.140 --> 00:13:19.600
This is a bit of a mixed blessing.

123
00:13:20.000 --> 00:13:26.890
On the one hand. it allows new features to be added to the header that turn out to be important but weren't in the original standard.

124
00:13:26.970 --> 00:13:36.340
On the other hand. these fields need processing. and so require extra features in the routers along the path. breaking the goal of a simple. dumb. minimal folding path.

125
00:13:36.480 --> 00:13:40.160
In practice. very few options are used or processed by the routers.

126
00:13:43.520 --> 00:13:48.040
I'm not going to show you the IPV foreheader and explain what all the fields do.

127
00:13:48.410 --> 00:13:52.270
I don't need you to I don't need you to remember where all the fields are.

128
00:13:52.610 --> 00:14:02.040
I don't remember all the locations myself. but I do want you to know what each field does. because it helps you understand. understand the scope of the IP service model.

129
00:14:02.660 --> 00:14:07.680
It should help cement your understanding and make it really clear that IP doesn't do a lot.

130
00:14:07.840 --> 00:14:15.360
It's a deliberately simple service. Here's a picture of an IPV foreheader. which is the most common header in use today.

131
00:14:15.440 --> 00:14:21.080
I've drawn it here in 32 bit words. with bit zero The 1st to be sent under the wire.

132
00:14:21.240 --> 00:14:22.900
Up in the top left hand corner.

133
00:14:23.300 --> 00:14:26.500
The shaded portion is the IPV forehead.

134
00:14:26.600 --> 00:14:41.380
It's followed by the data. The most important fields in the IP header are the destination I pay address. the source IP address. the protocol ID that tells us what's inside the data field.

135
00:14:41.730 --> 00:14:48.750
Essentially. it allows the destination host to de multiplex arriving data. sending them to the correct code to process the packet.

136
00:14:49.040 --> 00:15:03.120
If the project protocol idea idea has the value six. E.G.. then it tells us that the data contains a TCP segment. and so we can safely pass the datagram to the TCP code. and it will be able to pass the segment correctly.

137
00:15:03.930 --> 00:15:12.350
The Internet assign numbers. Authority. Iana defines over 140 different values of protocol ID representing different transport

138
00:15:12.410 --> 00:15:18.300
protocols. The version field tells us which version of I-P we're using.

139
00:15:18.600 --> 00:15:21.900
Currently. The legal values are IPV four and IPV six.

140
00:15:22.740 --> 00:15:24.990
This header is an IPV forehead.

141
00:15:25.190 --> 00:15:27.970
Will see IPV six headers in a later video.

142
00:15:28.690 --> 00:15:34.320
The total packet length can be up to 64 kb. including the header and all the data.

143
00:15:35.200 --> 00:15:41.000
The time to live or TTL field helps us to prevent packets accidentally looping in the network forever.

144
00:15:41.070 --> 00:15:44.610
Every router is required to decrement the TTL field.

145
00:15:44.770 --> 00:15:47.550
If it reaches zero. the router should drop the packet.

146
00:15:47.570 --> 00:15:55.250
This way. when the source sends the packet with a fixed TTL value. it's guaranteed to be destroyed by a router if it starts to travel in loops.

147
00:15:59.190 --> 00:16:04.390
Sometimes a packet is too long for the link it is about to be sent on the packet.

148
00:16:04.550 --> 00:16:12.210
ID Flags and fragment offset all help routes to fragment ip packets into smaller. self contained datagrams if need be.

149
00:16:12.490 --> 00:16:15.570
We'll learn how fragmentation works in the later video.

150
00:16:17.130 --> 00:16:21.410
The type of service field gives a hint to routers about how important this packet is.

151
00:16:22.820 --> 00:16:25.460
The head of length tells us how big the hitter is.

152
00:16:25.640 --> 00:16:29.300
Some headers have optional extra fields to carry extra information.

153
00:16:30.340 --> 00:16:39.150
Finally. a checksum is calculated over the whole header. so just in case the header is corrupted. were not likely to deliver a packet to the wrong destination by mistake.

154
00:16:41.110 --> 00:16:43.910
So in summary. IP is very important.

155
00:16:44.130 --> 00:16:47.190
We use it every time we send and receive packets in the Internet.

156
00:16:49.150 --> 00:16:52.190
IP provides a deliberately simple service.

157
00:16:52.550 --> 00:16:55.950
It is a simple. dumb. minimal service with four main features.

158
00:16:56.110 --> 00:16:59.010
It sends datagrams. hot by help across the Internet.

159
00:16:59.180 --> 00:17:01.640
The service is unreliable and best effort.

160
00:17:01.900 --> 00:17:05.200
There's no PERU state. making the protocol connectionless.

161
00:17:06.800 --> 00:17:15.040
At this point. you should feel comfortable with what the IP protocol is. what its service model is. and how it fits into the Internet. for layer hierarchy.

162
00:17:15.300 --> 00:17:20.940
If you have doubts. I suggest you rewatch this video and the one before it. on the four layer model.

163
00:17:21.620 --> 00:17:26.040
You'll also find lots of good references about how how IPV four works.

164
00:17:26.200 --> 00:17:32.400
Any good networking textbook will devote considerable space to explaining what IP is and why it was designed this way.

165
00:17:32.560 --> 00:17:38.520
E.g. Chapter four of the 6th edition of Computer Networking. A top down approach by Coresy and Ross.

166
00:17:38.680 --> 00:17:41.220
You also find a brief explanation on Wikipedia.

167
00:17:41.590 --> 00:17:46.190
I don't know.

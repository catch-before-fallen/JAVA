WEBVTT

0
00:00:00.300 --> 00:00:04.060 
这个视频讲的是我们称之为封装的架构原理
This video is about the architectural principle we call encapsulation.

1
00:00:04.620 --> 00:00:09.270 
封装是将分层和分组交换结合起来的结果
Encapsulation is the result of what happens when you combine layering and packet switching.

2
00:00:09.670 --> 00:00:13.230 
我们想把数据分解成离散的单元 我们称之为包
We want to break up our data into discreet units that we call packets.

3
00:00:13.430 --> 00:00:17.030 
但是 每个数据包包含来自多个层的数据
However, each packet contains data from multiple layers.

4
00:00:17.290 --> 00:00:21.230 
当你发送一个TCP段时 例如 它位于一个IP包中
When you send a TCP segment, e.g., it's sitting inside an IP packet,

5
00:00:21.510 --> 00:00:24.330 
也就是坐在一个乙烷框架里
which is, in turn sitting inside an ethanette frame.

6
00:00:25.070 --> 00:00:35.220 
封装就是它的工作方式 封装是组织信息和包的原则 这样就可以在维护层的同时让它们共享包的内容
Encapsulation is how this works. Encapsulation is the principle by which you organize information and packets so that you can maintain layers yet let them share the contents of your packets.

7
00:00:37.020 --> 00:00:41.780 
回想一下 分层让你把一个复杂的系统分解成更小的部分
Recall that layering let you take a complex system and break it down into smaller parts.

8
00:00:41.800 --> 00:00:45.880 
每一层都提供一个服务 这是网络对上面各层的抽象
Each layer provides a service, an abstraction of the network to the layers above.

9
00:00:46.260 --> 00:00:48.920 
它提供了一个减法使用层吹它
It provides a subtraction by using the layer blow it.

10
00:00:49.140 --> 00:00:53.260 
每一层都是独立的 所以只要它提供了预期的表面
Each layer is self contained, so as long as it provides the surface expected of it.

11
00:00:53.420 --> 00:00:59.490 
上面的层不需要担心关注点如何分离 每个层都可以独立发展
Layers above don't need to worry about how this separation of concerns which each layer can evolve independently.

12
00:00:59.610 --> 00:01:01.470 
就像现在的IP一样
Just as IP at the nower.

13
00:01:01.630 --> 00:01:05.450 
Claire不需要担心传输层TCP的更改
Claire doesn't need to have to worry about changes to TCP at the transport layer.

14
00:01:05.560 --> 00:01:09.920 
应用层(如ACDP)不必担心TCP的更改
Application layers, such as ACDP don't have to worry about changes to TCP.

15
00:01:10.000 --> 00:01:17.920 
例如 在过去的几年里 大多数操作系统已经改变了它们用来更好地处理不断增长的网络速度的TCP算法
E.g. the past few years, most operating systems have changed the exact TCP algorithms they used to better handle increasing network speeds.

16
00:01:18.180 --> 00:01:21.960 
但是网络浏览器使用旧算法和新算法都能很好地工作
But a web browser works fine using both the old algorithms and the new ones.

17
00:01:22.350 --> 00:01:30.030 
请注意 这张图层图使用的是七层OSI模型 所以让我们回到四层模型
Note that this picture of layers uses the seven layer OSI model, so let's crunch back down to the four layer model.

18
00:01:30.830 --> 00:01:36.590 
封装是一种原理 它允许我们采用协议层 并允许它们轻松地共享数据包中的存储
Encapsulation is the principle that lets us take protocol layers and let them easily share the storage within a packet.

19
00:01:36.880 --> 00:01:39.860 
这是我们在实际数据表示中的分层清单
It's our layering manifest in the actual data representation.

20
00:01:40.620 --> 00:01:48.820 
它的工作方式是每个协议层都有一些头部 然后是它的有效负载 然后是一些页脚 例如
The way this works is each protocol layer has some heads, followed by its payload, followed by some footers, e.g.

21
00:01:48.980 --> 00:01:51.920 
IP包头在目的地址中有一个源地址
an IP packet header has a source address in a destination address.

22
00:01:52.360 --> 00:01:58.180 
为了发送带有IP的TCP段 我们将TCP格式作为IP包的有效负载
To send a TCP segment with IP, we make the TCP format the payload of the IP packet.

23
00:01:58.520 --> 00:02:02.700 
这样 包IP报文就封装了TCP段
In this way, the pack IP packet encapsulates the TCP segment.

24
00:02:02.920 --> 00:02:04.980 
IP不知道也不关心它的有效载荷是什么
IP doesn't know or care what its payload is.

25
00:02:05.140 --> 00:02:07.040 
它只是向终端主机发送数据包
It just delivers packets to an end host.

26
00:02:07.360 --> 00:02:14.340 
当数据包到达时 主机查看有效负载内部 看到它是一个TCP段并相应地处理它
When the packet arrives, the host looks inside the payload, see that it's a TCP segment and process it accordingly.

27
00:02:15.460 --> 00:02:17.410 
这是一个更完整的例子
So here's a more complete example.

28
00:02:17.570 --> 00:02:22.470 
假设你正在用一台通过Wi-Fi(无线乙醇)连接的电脑浏览网页
Let's say that you're browsing the web using a computer connected through Wi Fi, wireless ethanol.

29
00:02:23.350 --> 00:02:26.670 
生成HTTPget请求的web眉毛
Your web brows that generates an HTTP get request.

30
00:02:26.740 --> 00:02:30.460 
这个get请求是TCP段的有效负载
This get request is the payload of a TCP segment.

31
00:02:30.640 --> 00:02:35.670 
封装HTTPget的TCP段成为IP包的有效负载
The TCP segment, in capsulating the HTTP get becomes the payload of an IP packet.

32
00:02:36.230 --> 00:02:43.570 
这个ip包依次封装TCP段 httbget是Wi-Fi帧的有效负载
This ip packet in turn encapsulating the TCP segment, and the httb get is the payload of a Wi Fi frame.

33
00:02:44.250 --> 00:02:48.170 
如果你看一下你的电脑发送的叮咬信息 它们看起来是这样的
If you were to look at the bites your computer sends, they'd look like this.

34
00:02:48.950 --> 00:02:59.060 
最外面的封装格式是Wi-Fi帧 里面是一个IP数据包 里面是一个TCP段 最后是HTTPget
The outermost encapsulating format is the Wi Fi frame, inside of which is an IP packet, inside of which is a TCP segment, inside of which finally is the HTTP get.

35
00:02:59.500 --> 00:03:03.620 
尼克是怎么画这个包的你可能会觉得很困惑
So how Nick has drawn this packet brings up something you might find very confusing.

36
00:03:03.620 --> 00:03:06.580 
实际上有两种方法来绘制包
It turns out there are two ways to draw packets.

37
00:03:07.000 --> 00:03:10.260 
差异来自于背景和您所使用的系统的哪个部分
The difference comes from background and what part of the system you work on.

38
00:03:10.370 --> 00:03:18.720 
Nick画的是包装盒 宠物在右边 第一个比特在右边 最后一个比特在左边
Nick has drawn the packens here, where the petters are on the right, the 1st bit of the packet is on the right, and the last bit of the packet is on the left.

39
00:03:18.880 --> 00:03:22.360 
这是完全有意义的路由器的交换机发送一个数据包
This makes total sense as a router of which switch sends a packet.

40
00:03:22.520 --> 00:03:24.950 
我们从左到右画包
We draw the packet moving from left to right.

41
00:03:25.110 --> 00:03:28.410 
第一个离开路线或开关的位 是最右边的位
So the 1st bit to leave the route or a switch, is the one of the far right.

42
00:03:29.290 --> 00:03:34.410 
但我用另一种方式画包 头在左边 脚在右边 就像这样
But I draw packets the other way, where the headers are on the left and the footers are on the right, like this.

43
00:03:35.410 --> 00:03:37.810 
第二种方法来自软件
This 2nd approach comes from software.

44
00:03:38.030 --> 00:03:41.570 
这是您在阅读itf文档和许多其他协议规范时将看到的内容
It's what you'll see when you read itf documents and many other protocol specifications.

45
00:03:41.640 --> 00:03:48.120 
这个想法是 数据包的开始在地址0 所以头的第一口在地址0
The idea is that the beginning of the packet comes at address zero, so the 1st bite of the header is at address zero.

46
00:03:48.280 --> 00:03:54.220 
由于地址从左到右增加 这意味着数据包的开始在左边 数据包的结束在右边
Since addresses increased from left to right, this means the beginning of the packet is on the left, and the end of the packet is on the right.

47
00:03:54.270 --> 00:03:56.530 
当然 这里没有对错之分
Of course, there isn't a right way or wrong way here.

48
00:03:56.690 --> 00:04:01.920 
这两种绘制包的方法都是有价值的 并且取决于您使用该绘图的目的 所以您应该对这两种方法都很熟悉
Both ways of drawing packets valuable and depend on what you're using the drawing for, so you should be comfortable with both.

49
00:04:02.040 --> 00:04:06.360 
我一般会把标头画在右边 而把它们画在左边
I'll generally draw headers on the right, and I'll generally draw them on the left.

50
00:04:06.580 --> 00:04:08.780 
下一个背景是电气工程和开关设计
Next background is electrical engineering and switched design.

51
00:04:08.940 --> 00:04:11.040 
我的专业是计算机科学和协议软件
Mine is computer science and protocol software.

52
00:04:13.960 --> 00:04:21.520 
现在让我们回到NIX 一个AP进入TCP段的例子 一个ibu包进入Wi-Fi帧的例子
So now let's go back to NIX, example of an AP to be get inside a TCP segment inside and ibu packet inside a Wi Fi frame.

53
00:04:21.970 --> 00:04:24.750 
让我们看看这在一个实际的网络中是什么样子的
Let's see what this looks like in an actual network with wire shark.

54
00:04:25.130 --> 00:04:29.310 
在我们开始录制之前 我打开了wireShark并录制了一组网络请求的痕迹
Before we started this recording, I turned on wire Shark and recorded a pack of trace of a web request.

55
00:04:29.330 --> 00:04:31.690 
让我们只看一个包
Let's look at just one packet.

56
00:04:32.410 --> 00:04:43.270 
这里我们可以看到wireshark是如何告诉我们里面是一个互联网帧 里面是一个IP数据包 里面是一个TCB段 里面是一个HPget
Here we can see how wire shark tells us that it's an Internet frame inside, which is an IP packet inside, which is a TCB segment inside, which is an HP get.

57
00:04:43.620 --> 00:04:49.320 
如果我点击每个粒子头 那么wireshark实际上会突出显示它们在数据包上的位置
If I click on each of these particle headers, then wire shark actually highlights where they are on the packet.

58
00:04:49.340 --> 00:04:59.710 
咬人 在wifi里面是IP 在IPSTCP里面
Bite. This Gobbley gook below wifi comes 1st Inside wifi is IP, inside IPS TCP.

59
00:05:00.580 --> 00:05:03.070 
在TCP内部 我们可以看到文本
And inside TCP, we can see the text

60
00:05:03.480 --> 00:05:05.140 
ac的值
of our ac to be get.

61
00:05:05.260 --> 00:05:10.380 
这种将协议封装在彼此之间的非常简单的方法为您提供了极大的灵活性
This very simple approach from capsuling protocols within each other gives you tremendous flexibility.

62
00:05:10.520 --> 00:05:15.120 
到目前为止 我们一直在讨论完全静态和不灵活的四层模型
So far, we've been talking about the four layer model of something completely static and inflexible.

63
00:05:15.460 --> 00:05:16.620 
但实际上并非如此
In practice, it's not

64
00:05:16.820 --> 00:05:21.610 
比如你可以用封装来递归层协议
like you can actually use encapsulation to recursively layer protocols.

65
00:05:21.850 --> 00:05:30.280 
例如 今天在企业办公室中非常常用的东西突然被称为虚拟专用网络 或VPN
E.g., something that's very commonly used today in offices of businesses is suddenly called a virtual private network, or VPN.

66
00:05:30.560 --> 00:05:31.470 
用一个虚拟
With a virtual

67
00:05:31.780 --> 00:05:37.700 
专用网络 你打开一个安全的网络 因为安全连接到一个你信任的网络 比如你的办公室 例如
private network, you open a secure network, because secure connection to a network you trust, such as your office, e.g.

68
00:05:37.860 --> 00:05:51.080 
使用传输层安全TLS 当您与Internet通信并发送IP包时 而不是正常发送它们 您在这个VPN连接内发送它们 因此IQ包将发送到您的办公室
using transport layer security TLS. When you communicate with the Internet and send IP packets, rather than send them normally, you send them inside this VPN connection, so the IQ packets go to your office.

69
00:05:51.100 --> 00:05:54.610 
此时 办公网络可以正常路由了
Now, at that point, the office network can route the normally.

70
00:05:54.910 --> 00:05:59.330 
这可以让你做一些事情 比如访问办公室内受保护的私有网络资源
This lets you do things like access private, protected network resources inside your office.

71
00:05:59.350 --> 00:06:07.590 
因此 与其到处喷洒网络保护 你只需要小心一项服务 即让人们通过虚拟专用网络登录到网络的服务
So rather than sprinkle network protections everywhere, you just have to be careful one service, the service that lets people log into the network over the virtual private network.

72
00:06:07.850 --> 00:06:16.510 
您可以使用虚拟专用网络或VPN网关来完成此操作 该计算机接受来自允许的VPN客户端的连接 并将流量转发到专用网络
You do this with the Virtual private Network, or VPN Gateway, a computer that accepts connections from permitted VPN clients and forward the traffic into the private network.

73
00:06:17.440 --> 00:06:19.200 
它是什么样的呢
So what does that look like?

74
00:06:19.200 --> 00:06:22.080 
假设我正在访问我公司的内部网站
Let's say I'm accessing my internal company website.

75
00:06:22.080 --> 00:06:25.390 
我的浏览器生成了一个H来获取
Well, my web browser generates an H to be get.

76
00:06:25.690 --> 00:06:33.110 
像往常一样 它把这个放在一个TCbe段中 它把它放在一个IP包中 目的地是公司的内部web服务器
Like usual, it puts this inside a TC be segment, which it puts inside an IP packet destined the company's internal web server.

77
00:06:33.710 --> 00:06:46.510 
但不是把这个IP包放在linkair框架中 我不能直接与我的计算机的内部web服务器通信 把这个IP包放在一个TLS段中 一个安全段
But rather than put this IP packet inside a linklair frame, I can't directly communicate with the internal web server my computer, put this IP packet inside a TLS segment, a secure segment.

78
00:06:46.540 --> 00:06:49.220 
TLS保护消息并使其保密
TLS protects the message and keeps it secret.

79
00:06:49.560 --> 00:06:55.380 
此TLS会话位于在虚拟专用网络网关处终止的TCP流中
This TLS session is inside a TCP stream that terminates at the virtual private network gateway.

80
00:06:55.420 --> 00:07:01.620 
因此 外层TCP段位于目的地为虚拟专用网络网关的IP包内部
So the outer TCP segment is inside an IP packet destined to the virtual private network gateway.

81
00:07:01.960 --> 00:07:06.500 
我们把这个外部IKI包放在一个链路帧中 并将它发送到下一个异常
We put this outer IKI packet inside a link frame and send it to the next abnormal.

82
00:07:06.880 --> 00:07:21.660 
它看起来是这样的 ACDP在TCP里面 在IP里面 TLS在TCP里面 在IP里面
So it looks like this. ACDP inside TCP, inside IP, inside TLS inside TCP inside IP inside.

83
00:07:21.900 --> 00:07:26.540 
现在 您已经了解了封装 即统一分层和包交换的原理
Now, you've learned about a capsulation, the principle that unifies layering and packets switching.

84
00:07:27.100 --> 00:07:33.260 
封装是我们如何将协议层以一种灵活的方式组装到数据包中 并保持它们的关注点分离
Encapsulation is how we take protocol layers and assemble them into packets in a way that's flexible and maintains their separation of concerns.

85
00:07:33.350 --> 00:07:38.030 
你看到了一个计算机的例子计算机如何封装一个ribquatrip
You saw an example of a computer how a computer can encapsulate a ribquat rip.

86
00:07:38.110 --> 00:07:40.310 
好吧 我要再次停止这种轻微的动作
Okay, I'm going to stop this slight again.

87
00:07:47.910 --> 00:07:52.550 
现在 您已经听说了封装 即统一分层和分组交换的原理
Now, you've heard about encapsulation, the principle that unifies layering and packet switching.

88
00:07:53.470 --> 00:08:00.590 
封装是我们采用协议层并以一种灵活的方式将它们组装到数据包中并保持关注点分离的方式
Encapsulation is how we take protocol layers and assemble them into packets in a way that's flexible and maintains the separation of concerns.


WEBVTT

0
00:00:00.000 --> 00:00:06.140 
在前几个视频中 你会看到很多关于去分层的参考 特别是在描述四层互联网的视频中
The last few videos, you see many references delayering, particularly in the video describing the four layer Internet.

1
00:00:06.300 --> 00:00:12.580 
分层是非常非常广泛使用的原则 在网络中已经使用了几十年 比互联网还早
Layering is very, very widely used principle, and has been used in networking for decades, predating the Internet.

2
00:00:12.920 --> 00:00:15.110 
事实上 分层是一种设计原则
In fact, layering is a design principle used

3
00:00:15.220 --> 00:00:21.780 
还有广泛的外部网络 它通常被用作许多类型的计算机系统的设计原则
widely outside networking as well. It's commonly used as a design principle in many, many types of computer system.

4
00:00:21.950 --> 00:00:23.150 
分层的原因有很多
There are lots of reasons for layering,

5
00:00:23.370 --> 00:00:25.110 
我们会探讨其中的一些
and we'll explore some of them.

6
00:00:25.270 --> 00:00:28.750 
在这个视频中 我们将探讨什么是分层
In this video. We'll explore what layering is.

7
00:00:28.910 --> 00:00:39.450 
我们将研究通信和计算机系统中分层的一些简单例子 并解释为什么如此多的系统不是由自然环境主导 就是由故意设计主导
We'll look at some of the simple examples of layering in communication and computer systems, and we'll explain why so many systems are led either by natural circumstance or deliberately by design.

8
00:00:40.390 --> 00:00:42.830 
让我们从分层的定义开始
Let's start with the definition of layering.

9
00:00:43.270 --> 00:00:50.040 
分层是我们将一个系统组织成许多独立的功能组件或层的名称
Layering is the name we give to the organization of a system into a number of separate functional components, or layers.

10
00:00:51.440 --> 00:00:55.860 
这些层是有层次的 它们按顺序交流单词
The layers are hierarchical, and they communicate sequentially words.

11
00:00:56.020 --> 00:00:59.880 
每一层都有一个接口 只与正上下一层连接
Each layer has an interface only to the layer directly above and below.

12
00:01:00.880 --> 00:01:09.740 
每一层使用下面的层提供的服务和自己的私有处理向上面的层提供定义良好的服务
Each layer provides a well defined service to the layer above using the services provided by layers below and its own private processing.

13
00:01:10.980 --> 00:01:18.270 
日常生活中有很多分层的例子 特别是当一项服务被故意或自然地放在另一项服务之上时
There are many examples of layering in everyday life, particularly when one service is deliberately or naturally laid on top of another.

14
00:01:18.510 --> 00:01:25.790 
例如 如果你正在寻找机票 你可能会访问一个访问经纪网站 如谷歌Flights hipmunk或Kayak
E.g., if you're looking for airplane tickets, you might visit a visit a brokerage website, such as Google Flights, hipmunk or Kayak.

15
00:01:26.640 --> 00:01:32.400 
这些网站让你通过与单一服务沟通就能找到各种航空公司的机票
These websites let you find tickets across a wide range of airlines by communicating with a single service.

16
00:01:32.680 --> 00:01:37.320 
你可以去每个航空公司的网站查询他们有哪些机票
You could instead go to the website of every airline to query what tickets they have available.

17
00:01:37.580 --> 00:01:44.980 
经纪网站在每个航空公司的顶部为你提供服务层 为你抽象出每个航空公司网站的细节
The brokerage website is providing you a service layer on top of each airline, abstracting away the details of each airline's website for you.

18
00:01:45.300 --> 00:01:51.100 
现在 如果我们看一下每家航空公司的封面 他们在不同的航线上驾驶不同类型的飞机
Now, if we look under the covers of each airline, they fly different types of airplane over different routes.

19
00:01:51.400 --> 00:01:59.120 
飞机负责提供服务的细节 并为您提供在两个机场之间的特定航班有效的简单抽象机票
The airplane takes care of the details of providing the service, and offers you the simple abstraction of a ticket valid for a particular flight to take you between two airports.

20
00:01:59.560 --> 00:02:04.920 
他们还隐藏了许多其他细节 比如他们是如何提供 呃 他们提供的糟糕的套装食物
The hiding many other details too, such as how they provide the, uh, the awful suit food they serve.

21
00:02:05.150 --> 00:02:09.950 
在许多情况下 他们有许多供应商提供膳食 饮料 燃料等
In many cases, they have a number of suppliers to provide meals, drinks, fuel and so on.

22
00:02:10.110 --> 00:02:12.850 
这些对我们消费者来说都是隐藏的
Each of those are naturally hidden from us, the consumer.

23
00:02:13.420 --> 00:02:23.580 
这种关注点分离允许层次结构中的每一层都专注于做好自己的工作 并向上面的层提供定义良好的服务
This separation of concerns allows each layer in the hierarchy to focus on doing its job well and provide a well defined service to the layer above.

24
00:02:26.060 --> 00:02:31.760 
另一个向互联网靠拢的著名例子是邮政服务
Another well known example of layering closer to the Internet is the postal service.

25
00:02:32.440 --> 00:02:35.480 
想象一下 我有一本书想要寄去填满
Imagine that I have a book that I want to send to fill.

26
00:02:37.120 --> 00:02:44.690 
我把书放在一个信封里 填上地址和我的地址 然后交给奥利弗拿去邮箱
I place the book in an envelope, add fills address and mine, and then handed over to Olive to take to the mailbox.

27
00:02:45.690 --> 00:02:54.360 
邮政部门对邮件进行分类 然后通过各种不同的方式发送  飞机 邮车 火车等
The postal service sorts the mail, then sends it by a variety of different means airplanes, mail trucks, trains, etc.

28
00:02:54.740 --> 00:02:57.100 
直到送到菲尔附近的分拣处
Until it reaches a sorting office near Phil.

29
00:02:57.740 --> 00:03:02.980 
邮差把信交给菲尔 菲尔打开信 发现里面有本书
The mailman delivers the letter to Phil, who opens it and finds the book inside.

30
00:03:05.650 --> 00:03:09.230 
这项服务显然是放在最上面的
The service is clearly layed at the top.

31
00:03:09.390 --> 00:03:15.420 
我不在乎这些信是用飞机 卡车还是气垫船寄来的
I don't care how the letters get from me to fill, whether they go by airplane, truck or hovercraft.

32
00:03:15.720 --> 00:03:21.210 
我不关心这本书走的路线 也不关心它沿途经过多少个分拣处
And I don't care about the the route that the book takes or how many sorting offices it passes through along the way.

33
00:03:21.290 --> 00:03:25.130 
我不介意Olivewalk是跳过自行车还是跑向邮箱
I don't mind whether Olive walk skips bicycles or runs to the mailbox.

34
00:03:25.320 --> 00:03:27.940 
我不在乎她把信寄到哪个邮箱
I don't care which mail box she posts the lettering.

35
00:03:28.300 --> 00:03:35.360 
我希望底层为我抽象出细节 为我提供一个简单的服务模型
I want the lower layers to abstract away the details for me, provide, providing me with a simple service model.

36
00:03:35.360 --> 00:03:40.310 
我把书放在信封里 下面的几层依次把它送到信封里
I put the book in an envelope, and the layers below deliver it to fill in turn.

37
00:03:40.490 --> 00:03:43.110 
奥利芙不需要知道邮局是怎么送信的
Olive doesn't need to know how the postal service delivers the letter.

38
00:03:43.490 --> 00:03:46.590 
她只是通过寄信与下面的一层人交流
She simply communicates with a layer below by posting the letter.

39
00:03:46.600 --> 00:03:53.960 
菲尔只是想让这本书注意到 每一层只与上面和下面的层通信
Phil just wants the book notice that each layer communicates only with the layers above and below.

40
00:03:54.060 --> 00:04:01.460 
如果邮政部门部署了新的火车或开始使用不同的航空货运服务 菲尔和我不需要知道这些
If the postal service deploys new trains or starts using a different airline freight service, phil and I don't need to know about it.

41
00:04:01.650 --> 00:04:04.650 
换句话说 因为交流就是上下的
In other words, because communication is simply up and down.

42
00:04:04.810 --> 00:04:09.990 
通过在层之间定义良好的接口 我们可以随着时间的推移独立地改进每一层
With a well defined interface between layers, we can improve each layer independently over time.

43
00:04:10.310 --> 00:04:17.190 
例如 如果我想要更快 有保证的递送 我可以把信封交给DHL或Fedex这样的快递公司
E.g., if I want faster, guaranteed delivery, I could handle the envelope to a carrier such as DHL or Fedex.

44
00:04:17.510 --> 00:04:19.290 
界面几乎相同
The interface is almost the same.

45
00:04:19.450 --> 00:04:25.950 
我只是给他们一个信封和钱的分层是故意为许多计算机系统设计的
I simply give them an envelope and money layering is deliberately designed to many computer systems.

46
00:04:26.270 --> 00:04:29.230 
当我们写程序时 这是T-Y编辑 一个程序
When we write programs, this is T-Y editing, a program.

47
00:04:29.390 --> 00:04:37.230 
我们使用一种语言来创建源代码 这种语言抽象了操作系统的细节 具有虚拟内存工作 并具有硬件的底层细节
We create source code using a language that abstracts away the details of the operating system, have virtual memory works, and have the low level details of the hardware.

48
00:04:37.270 --> 00:04:45.670 
好吧 c语言隐藏了很多细节 但是很多其他语言 比如Java和Python 故意从底层向我们展示
Okay, so c is in great hiding the details, but many other languages, such as Java and Python, deliberately show us from how the lower layers.

49
00:04:46.560 --> 00:05:04.570 
作为程序员 我们通过提交源代码与编译器下面的层进行通信 编译器是一个独立的功能组件 它负责几个任务 如词法分析 解析代码 预处理声明和共量生成
As a programmer, we communicate with the layer below the compiler by handing at our source code, the compilers a self contained, functional component that was responsible for several tasks such as lexical analysis, parsing our code, pre processing declarations and cogenerous generation.

50
00:05:04.670 --> 00:05:11.950 
是优化 编译器生成目标代码 然后将其传递给逗留器
Is optimization. The compiler generates object code, which then it then passes to the linger.

51
00:05:12.340 --> 00:05:15.480 
链接器将库的已编译目标文件链接在一起
The linker links together the compiled object files of libraries.

52
00:05:15.740 --> 00:05:20.790 
它生成一个可执行文件 CPU是真实的 然后是虚拟的
It generates an execuable file, the CPU real, a virtual then

53
00:05:21.140 --> 00:05:27.260 
执行外套 如果你有编写计算机程序的经验 分层的好处是相当明显的
executes the coat. If you have experience writing computer programs, the benefits of layering are fairly clear.

54
00:05:27.360 --> 00:05:28.790 
在这个例子中 larry
In this example, larry

55
00:05:29.000 --> 00:05:41.460 
将编写在硬件上执行的程序的整体问题分解为模块或功能组件 每个模块或功能组件都具有定义良好的角色 并向上面一层提供定义良好的服务
breaks down the overall problem of writing programs that execute on hardware into modules or functional components, each with a well defined role and providing a well defined service to the layer above.

56
00:05:41.810 --> 00:05:45.770 
它还提供了一个清晰的关注点分离
It also provides a clear separation of concerns.

57
00:05:45.810 --> 00:05:49.690 
编译器可以专注于词法分析 解析等
The compiler can focus on lexical analysis, parsing and so on.

58
00:05:49.760 --> 00:05:52.920 
链接器可以专注于有效地将对象拼接在一起
The linker can focus on efficiently piecing objects together.

59
00:05:53.240 --> 00:06:00.850 
双方都不必担心对方的工作 随着技术和知识的进步 每一个都可以随着时间的推移得到改进 升级和替换
Neither has to worry about the job of the other, and each can be improved, upgraded and replaced over time as technology and know how progresses.

60
00:06:01.130 --> 00:06:09.950 
例如 我们可以用G-C-C替换一个商业海编译器 反之亦然 而不需要改变链接器或我们使用的语言
E.g. we might swap out a commercial sea compiler with G-C-C, or vice versa, without needing to change the linker or the language we use.

61
00:06:13.680 --> 00:06:26.930 
当Nick1st开始做幻灯片时 我很兴奋他把编译器作为分层的一个例子 这是一个很好的例子 说明了分层的好处 以及有时你需要打破分层 尽管有非常消极的后果
When Nick 1st dropped to be slides, I was excited that he put compilers in as an example of layering, the great example of both the benefits of layering as well as how sometimes you need to break layering despite the very negative consequences.

62
00:06:27.970 --> 00:06:31.210 
让我们以sea编程语言为例
So let's take the sea programming language as an example.

63
00:06:31.430 --> 00:06:34.960 
一般来说 几乎任何处理器都可以强制执行一段海上代码
Generally speaking, a piece of sea code can be compelled for almost any processor.

64
00:06:35.120 --> 00:06:45.440 
我们可以用seacode 就像这个语句 I++ 并将它用于一个手臂处理器和一个电话 一个x8664+cern 一台笔记本电脑 是微控制器和超精密洗碗机
We can take sea code, like this statement, I plus plus, and compel it for an arm processor and a phone, an x 8664 plus cern, a laptop, are micro controller and ultramotar dishwasher.

65
00:06:45.520 --> 00:06:50.520 
通过这种方式 sea代码是独立于硬件的 所以它将层保留在这里
In this way, the sea code is hardware independent, and so it keeps the layer in here.

66
00:06:51.560 --> 00:06:57.970 
但有时我们需要我们的Seacoat做一些特殊的事情 只有我们的处理器可以做 例如
But sometimes we need our Seacoat to do something special that only our processor can do, e.g.

67
00:06:58.130 --> 00:07:04.470 
xv664处理器有各种微控制器看不到的特殊指令
an XV six 64 processor has all kinds of special instructions that a micro controller doesn't see.

68
00:07:04.630 --> 00:07:08.090 
允许您直接包括一个供应代码
Allows you to include a suppli code directly.

69
00:07:08.330 --> 00:07:14.010 
像Linux和Windows这样的操作系统内核之类的软件用于一些最低级别的实现
Software like operating system kernels such as Linux and Windows uses for some of those lowests level implementations.

70
00:07:14.050 --> 00:07:21.690 
sea提供的分层隐藏了这个细节 所以它不允许你直接这样做 但你必须这样做才能实现你的目标
The layering that sea provides hides this detail, so it doesn't let you do so directly, but you have to do so to achieve your goal.

71
00:07:21.770 --> 00:07:26.210 
所以Oyce内核包含这样做的汇编代码
So Oyce kernels include assembly code doing so.

72
00:07:26.390 --> 00:07:36.710 
这意味着代码不再是独立于Linux上下文的层 为Arm编写的程序集只适用于Arm 所以你必须为每一层编写一个版本的代码
This means that the code is no longer layer independent the Linux context, which assembly written for Arm only works for Arm, so you have to write a version of this code for each layer.

73
00:07:37.090 --> 00:07:42.720 
如果Linux希望在新的处理器上运行 开发人员需要为该处理器编写新的汇编代码
If Linux wants to run in a new processor, developers need to write new assembly code for that processor.

74
00:07:43.400 --> 00:07:51.690 
所以这是一个很好的例子 因为他们选择了在简化系统中分离关注点的层的好处 就像编程比组装更容易一样
So this is a great example, because they chose the benefits of layers that separate concerns in simplifier system, just as programming seas easier than assembly.

75
00:07:51.810 --> 00:07:55.170 
但有时你必须打破层的界限
But sometimes you have to break the layer boundaries.

76
00:07:55.260 --> 00:07:57.380 
这样做的代价是巨大的
Doing so has a huge cost.

77
00:07:57.380 --> 00:08:01.900 
突然之间 你不再独立于底层 极大地限制了灵活性
Suddenly you are no longer independent the lower layer, greatly limiting flexibility.

78
00:08:01.950 --> 00:08:07.670 
所以有时候你必须这么做 但只在你真的 真的必须这么做的时候
So sometimes you have to do it, but do so only when you really, really have to.

79
00:08:07.670 --> 00:08:17.520 
正如我们将看到的 当今Internet中的许多实际操作挑战都是由于人们打破了分层 并假设在他们的服务接口之上和之下的东西
As we'll see, a lot of the practical operational challenges in the Internet today result from people breaking layering and assuming things above and below their service interface.

80
00:08:17.920 --> 00:08:25.500 
通过跨层优化来改进互联网的压力一直存在 而灵活性也因此而丧失
There's a continual tension to improve the Internet by making cross layer optimizations, and the resulting loss of flexibility.

81
00:08:26.540 --> 00:08:39.310 
我们将会看到 一个很明显的例子是NATS 或者NETWORKRA 网络地址转换器 非常有用的设备 不幸的是 几乎不可能向互联网添加新的传输粒子
We'll see. One really telling example of this was something called NATS, or NETWORKRA, Network address translators, tremendously useful devices that have, unfortunately made it almost impossible to add new transport particles to the Internet.

82
00:08:40.460 --> 00:08:45.100 
总的来说 我们在计算机系统中使用分层有五个主要原因
So in summary, there are five main reasons we use layering in computer systems.

83
00:08:46.020 --> 00:08:51.450 
模块化 它将系统分解成更小 更易于管理的模块
Modularity. It breaks down the system into smaller, more manageable modules.

84
00:08:51.930 --> 00:08:56.530 
定义良好的服务 每一层都为上一层提供一个定义良好的服务
The well defined service. Each layer provides a well defined service to the layer above.

85
00:08:56.680 --> 00:09:03.420 
第三 重用上面的层可以依赖其他人所投入的所有艰苦工作来实现下面的层
3rd reuse a layer above can rely on all the hard work put in by others to implement the layers below.

86
00:09:03.580 --> 00:09:07.390 
每当我们构建一个新系统时 它可以节省我们编写每一层的时间
It saves us the time to write each layer whenever we build a new system.

87
00:09:07.950 --> 00:09:15.580 
第四 分离关注点 每一层都可以专注于自己的工作 而不必担心其他层如何完成自己的工作
4th separation of concerns. Each layer can focus on its own job without having to worry about how other layers do theirs.

88
00:09:15.740 --> 00:09:25.600 
唯一的通信是上下层之间的通信 因此它有助于尽可能地保持一层在内部处理数据 最大限度地减少层之间的复杂交互
The only communication is up and down the layers, so it helps keep one layers processing in data local an internal where possible, minimizing the complex interactions between layers.

89
00:09:25.640 --> 00:09:29.560 
第五 它允许每个功能的持续改进
5th it allows the a continuous improvement of each function.

90
00:09:30.990 --> 00:09:39.150 
第六好处是特定于领先的通信系统 如互联网 即码头到对等通信
6th 6th benefit is specific to lead communication systems such as the Internet, that is pier to peer communications.

91
00:09:39.270 --> 00:09:48.870 
在四层Internet模型中 我们看到了每一层与另一个系统上的对等体通信的良好程度 使用下面的层提供的传递服务
In the four layer Internet model, we saw how well each layer communicates with its peer on another system, using the delivery service provided by it provided by the le layers below.


WEBVTT
0
00:00:01.740 --> 00:00:05.980
What ultimately makes networks interesting are the applications that use them.

1
00:00:06.240 --> 00:00:07.840
David Clark. one of the key contributors to

2
00:00:08.280 --> 00:00:17.750
Internet s design. once wrote. the current exponential growth of the network seems to show that connectivity is its own reward. and it is more valuable than any individual

3
00:00:18.040 --> 00:00:19.950
application. such as male or the worldwide Webb.

4
00:00:20.880 --> 00:00:26.840
Connectivity is the idea that two computers in different parts of the world can connect to one another and exchange data.

5
00:00:26.880 --> 00:00:32.840
If you connect your computer to the Internet. you can suddenly talk with all of the other computers connected to the Internet.

6
00:00:33.040 --> 00:00:39.540
Let's look at exactly what that means. and how some modern applications. the Worldwide Webb. skype and bit Torrent. use it.

7
00:00:40.230 --> 00:00:57.990
The tremendous power of network applications is that you can have multiple computers. each with their own private data. each perhaps owned and controlled by different people exchange information. unlike your local applications. which can only access data that resides on your local system. networked applications can exchange data across the world.

8
00:00:58.190 --> 00:01:01.590
E.g. think of using a web browser to read a magazine.

9
00:01:01.710 --> 00:01:06.310
The server is run by the publisher and has which has all of the magazine articles.

10
00:01:06.530 --> 00:01:08.980
And it might also have all the articles from past issues.

11
00:01:09.140 --> 00:01:13.440
As articles are corrected or added. you can immediately see the newer versions in newer content.

12
00:01:13.820 --> 00:01:18.000
Entire back catalog of articles might be too much free to download. so you can load them on demand.

13
00:01:18.210 --> 00:01:23.110
If you didn't have a network. then you need someone to send you a DVD. or you as beastick with the latest issue.

14
00:01:23.750 --> 00:01:31.250
So the basic model is that you have two computers. each running a program locally. and these two programs communicate over the network.

15
00:01:31.590 --> 00:01:37.090
The most common communication model used is a bidirectional. reliable stream of bites.

16
00:01:38.940 --> 00:01:48.220
So program A running on computer A can write data which goes over the network. such that then program B running on computer B can read it.

17
00:01:49.410 --> 00:01:53.770
Similarly. program B can write data that program A can read.

18
00:01:54.530 --> 00:02:03.960
There are other modes of communication. which will talk about later in the course. but a reliable. by directional bitestream is by far the most common one used in networks today.

19
00:02:04.320 --> 00:02:06.640
Let's walk through what this looks like.

20
00:02:06.730 --> 00:02:11.730
Computer B on the right is waiting for other computers to connect to it.

21
00:02:13.130 --> 00:02:22.840
Computer A on the left wants to communicate with be E.G.. though it's drawn here as a server. it could be a mobile phone running a web browser.

22
00:02:23.580 --> 00:02:26.100
A and B set up a connection.

23
00:02:26.900 --> 00:02:32.710
Now. when a right state of the connection. this data travels over the network. and be can read it.

24
00:02:34.110 --> 00:02:40.100
Similarly. if B right state of the connection. that date of travels over the network. and A can read it.

25
00:02:42.540 --> 00:02:51.070
Either side can close the connection. e.g.. when the web browser is done requesting data from the web server. it can close the connection.

26
00:02:52.900 --> 00:02:56.820
Similarly. if the server wants to. we can close the connection as well.

27
00:02:57.540 --> 00:03:02.800
If you've ever seen an error message in a web browser saying. connection reset by peer. that's what this means.

28
00:03:02.960 --> 00:03:06.300
The web server closed the connection when the web browser wasn't expecting it.

29
00:03:06.750 --> 00:03:08.830
Of course. the server can refuse the connection as well.

30
00:03:08.990 --> 00:03:15.410
You've probably seen connection refuse messages. or have a browser wait for a long time because the server isn't even responding with the refusal.

31
00:03:16.500 --> 00:03:22.660
Now that we've seen the basic way networked applications communicate. let's look at our 1st example. the World Wide Webb.

32
00:03:22.860 --> 00:03:28.780
The Worldwide Webb uses something called ACDP. which stands for Hypertext Transfer Protocol.

33
00:03:28.780 --> 00:03:35.500
When you see ACTP coal and Slash slash in your browser. that means it's communicating using ACTP.

34
00:03:37.120 --> 00:03:40.420
We'll dig much deeper to the details of HCTB later in the course.

35
00:03:40.580 --> 00:03:44.140
We will cover applications. For now. I'm just going to give a very high level overview.

36
00:03:44.980 --> 00:03:49.540
In HDP. a client opens a connection to a server and sends commands to it.

37
00:03:49.590 --> 00:03:53.390
The most common command is Get. which requests a page.

38
00:03:55.350 --> 00:03:59.350
HTTP was designed to be a document centric way for programs to communicate.

39
00:03:59.710 --> 00:04:11.960
E.g. if I type HTTP. W-W-W. dot Stanford. I-E-D-U in my browser. the browser opens a connection to the server. W-W-W. does Stanford. D-E-D-U. and sends a get request for the root page of the site.

40
00:04:13.120 --> 00:04:19.580
The server receives the request checks of its valid and the user can access that page and sends a response.

41
00:04:19.820 --> 00:04:22.950
The response has an numeric code associated with. e.g.

42
00:04:23.110 --> 00:04:29.970
if the server sends a 200 okay response to a get. this means that the request was accepted. and the rest of the response has the document data.

43
00:04:33.150 --> 00:04:56.650
In the example of the ww dot Stanford. D-E-D webpage. a Twitter care response would include the hypertext that describes the main Stanford page. though other kinds of requests. such as put delete and info. as well as other responses. such as 400. which means that there was a bad request. may be was malformed. because 80 to be his document centre clients. client requests. name. a file.

44
00:04:56.890 --> 00:04:58.790
HTP is all An Asky. Text.

45
00:04:58.950 --> 00:05:03.270
Its human readable. E.g. The beginning of a gut request for Stanford looks like this.

46
00:05:03.480 --> 00:05:10.140
The beginning of a response to a successful request looks like this.

47
00:05:11.860 --> 00:05:14.480
The basic model is simple client.

48
00:05:14.640 --> 00:05:17.240
A client sends a request by writing to the connection.

49
00:05:17.400 --> 00:05:23.140
The server reads this request. process it and writes a response to the connection. which the client then reads.

50
00:05:25.300 --> 00:05:28.070
Let's look at a 2nd application. bit Torrent.

51
00:05:28.230 --> 00:05:28.790
Bit Torrent is a

52
00:05:28.950 --> 00:05:40.310
program that allows people to share and exchange large files. unlike the Webb. where a client request documents from a server in bittorn. a client request documents from other clients. so their single client can request from many others.

53
00:05:40.410 --> 00:05:44.930
In parallel. Bit torn breaks files up into chunks of data called pieces.

54
00:05:44.930 --> 00:05:51.920
When a client downloads a complete piece from another client. it then tells other clients it has that piece. they can download it to.

55
00:05:52.340 --> 00:05:58.930
These collections of collaborating clients are called swarms. so we talk about a client joining or leaving the swarm.

56
00:05:59.730 --> 00:06:05.630
Bitchart uses the exact same mechanism as the World Wide Webb. are reliable by directional. bystream.

57
00:06:05.890 --> 00:06:08.070
But it uses it in a slightly more complex way.

58
00:06:08.370 --> 00:06:13.270
When the client wants a download a file. it 1st has to find something called a torrent file.

59
00:06:13.350 --> 00:06:18.480
Usually you find this using the World Wide Webb and download it using you guessed it HTTP.

60
00:06:19.000 --> 00:06:23.520
The torrent file describes some information about the data file you want a download.

61
00:06:23.560 --> 00:06:26.980
It also tells bit torn about who the tracker is.

62
00:06:27.140 --> 00:06:34.290
For that torrent. a tracker is a no that keeps track. hence the name of what clients are members of the swarm.

63
00:06:35.390 --> 00:06:43.030
To join a torrent. your client contacts the tracker again over its EDP to request the list of other clients.

64
00:06:44.160 --> 00:06:49.760
Your client opens connections to some of these other clients and starts requesting pieces of the file.

65
00:06:49.760 --> 00:06:52.760
These clients in turn can request pieces on their own.

66
00:06:53.040 --> 00:06:59.300
Furthermore. when a new client joins this form. the tracker might tell this new client to connect your client.

67
00:06:59.720 --> 00:07:06.910
So rather than a single connection between a client and a server. you have a dense graph of connections between clients. dynamically exchanging data.

68
00:07:08.110 --> 00:07:12.690
For a 3rd and final application. let's look at the Skype. the popular voice chat and video service.

69
00:07:12.850 --> 00:07:17.800
Skype is a prietary system. Doesn't have any official documentation on documentation on how it works internally.

70
00:07:18.140 --> 00:07:23.800
In 2008. some researchers a Columbia figured out mostly how it works by looking at wherein wind sky. clients send messages.

71
00:07:24.190 --> 00:07:26.650
The messages were encrypted. those they couldn't look inside.

72
00:07:26.870 --> 00:07:36.480
In 2011. however. a Theme Bushman of reverse engineered the protocol and published open source code. so now we have a better sense of how the protocol works in its most simple mode.

73
00:07:36.640 --> 00:07:41.380
When you want to call someone in Skype. it's a simple client server exchange. sort of like HTTP.

74
00:07:41.730 --> 00:07:45.610
You the collar open a connection to the recipient.

75
00:07:46.970 --> 00:07:52.180
If the recipient accepts your call. you start exchanging voice video or chat data.

76
00:07:52.220 --> 00:07:57.140
But unlike the web. where there's a client in a server. in the sky case. you have two clients.

77
00:07:57.570 --> 00:08:03.910
So rather than having a personal computer request something from a dedicated server. you have two personal computers requesting data from each other.

78
00:08:04.170 --> 00:08:08.270
This difference turns out of a really big implication to house quite Skype works.

79
00:08:09.790 --> 00:08:14.590
The complication comes from something called a NAT. or network address translate.

80
00:08:14.920 --> 00:08:19.220
That's are everywhere today. a small home wireless router than that.

81
00:08:19.380 --> 00:08:22.170
When a mobile phone connects the Internet. it's behind a nap.

82
00:08:22.210 --> 00:08:24.350
We'll cover them in greater detail litter in the course.

83
00:08:24.510 --> 00:08:34.160
But for now. all you need to know is that if you're behind a net. then you can open connections out to the Internet. but other nodes on the Internet can't easily open connections to you.

84
00:08:34.220 --> 00:08:45.710
In this example. this means that Client B can open connections to other notes freely. but it's very hard for other notes to open connections to Client B. that's what this red green gradient is showing.

85
00:08:45.870 --> 00:08:49.990
Connections coming from the green side work fine. but connections coming from the red side don't.

86
00:08:50.150 --> 00:08:55.890
So the complication here is that if client A wants to call client B. it can't open a connection.

87
00:08:56.050 --> 00:08:57.350
It can't go through the NAP.

88
00:08:57.390 --> 00:08:59.070
Skype has to work around this.

89
00:09:00.320 --> 00:09:02.780
It does so using something called a rendezvous server.

90
00:09:02.940 --> 00:09:06.670
When you log into Skype. your client opens connections to a network of control servers.

91
00:09:06.830 --> 00:09:10.890
In this case. client B opens a connection to the rendezvous server.

92
00:09:11.150 --> 00:09:16.500
This works fine because the server isn't behind a net. and so Client B can open connections without any problems.

93
00:09:16.840 --> 00:09:21.700
When a client A calls Client B. it sends a message to the rendezvous server.

94
00:09:21.920 --> 00:09:34.470
Since the server has an open connection to client B. it tells me that there's a call request for may call dialogue pops up on Client B If client BE accepts the call. then it opens a connection to Client A.

95
00:09:35.270 --> 00:09:39.650
Client A was trying to open a connection to Client B. but since B was behind the net. it couldn't.

96
00:09:39.810 --> 00:09:47.000
So instead. it sends a message to a computer that Client B is already connected to. which then asks Client B to open a connection back to client A.

97
00:09:47.160 --> 00:09:50.420
Since Client A is behind the net. this connection can open normally.

98
00:09:50.690 --> 00:09:56.070
This called a reverse connection. because it reverses the expected direction for initiating the connection.

99
00:09:56.190 --> 00:10:05.500
Client A is trying to connect to client B. but instead client B opens a connection to client A. this happens in Skype. because Skype clients are typically personal machines.

100
00:10:05.800 --> 00:10:08.560
It's rare for publicly accessible web servers to be behind nets.

101
00:10:08.720 --> 00:10:13.300
Since you want the server to be accessed by over on the Internet. putting it behind and out is a bad idea.

102
00:10:13.520 --> 00:10:15.470
Therefore. opening connection to web servers is easy.

103
00:10:15.850 --> 00:10:23.290
Personal computers. however. often behind nets for security and other reasons that. for Skype has to incorporate some new communication patterns to work around.

104
00:10:24.280 --> 00:10:25.180
So what does sky

105
00:10:25.300 --> 00:10:27.040
do if both clients are behind that?

106
00:10:27.220 --> 00:10:33.880
We can't reverse the connection. Client A can't open a connection to client B and Client B can't open a connection to client A.

107
00:10:34.570 --> 00:10:35.710
To handle this case.

108
00:10:36.170 --> 00:10:39.410
skype introduced a 2nd kind of server called a relay.

109
00:10:39.830 --> 00:10:45.150
Relays can't be behind notes. If both client and client beer behind that. then they communicate through a relay.

110
00:10:45.370 --> 00:10:47.710
They both open connections to the relay.

111
00:10:48.490 --> 00:10:54.490
When client A sends data. really affords it two client B through the connection that be open.

112
00:10:55.480 --> 00:10:59.740
Similarly. inclined B sends data. relay affords a decline A through the connection.

113
00:10:59.760 --> 00:11:08.150
client. AO In summary. we've seen the most common communication models network applications are reliable by directional bitestream.

114
00:11:08.380 --> 00:11:14.560
This allows two programs running on different computers to exchange data and abstracts away the entire network to a simple read write relationship.

115
00:11:15.290 --> 00:11:20.150
Although it's a very simple communication model. it can be used in very inventive and complex ways.

116
00:11:20.310 --> 00:11:23.370
We looked at three examples the world. like Webb. bit torn and Skype.

117
00:11:23.540 --> 00:11:25.140
The world Doug. Webb is a client server model.

118
00:11:25.160 --> 00:11:27.860
The client opens a connection to a server and equest documents.

119
00:11:28.020 --> 00:11:29.400
The server is response with the document.

120
00:11:29.890 --> 00:11:36.970
Bit Torrent is appear to pier model. where swarms of clients open connections to each other in exchange pieces of data. creating a dense network of connections.

121
00:11:37.330 --> 00:11:38.910
Skype is a mix of the two.

122
00:11:39.070 --> 00:11:42.630
When sky clients can communicate directly. they do soon appear to appear fashion.

123
00:11:42.790 --> 00:11:47.970
But sometimes the clients aren't able to open connections directly. and instead go through rendezvous relay servers.

124
00:11:48.100 --> 00:11:54.940
You can see how what looks like a very simple abstraction. a biodirectional. reliable bite stream. can be used in many interesting ways.

125
00:11:55.110 --> 00:12:03.750
By changing how programs open connections and what different programs do. we can create complex applications ranging from document retrieval to swarming downloads to ib to lephony trackers.

126
00:12:03.910 --> 00:12:11.150
And bittorn E.G. have very different data in a very different role in the clients. just as Skype has relays in rendezvous servers in addition to its Clients.

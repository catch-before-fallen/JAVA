WEBVTT

0
00:00:00.000 --> 00:00:06.140 
The last few videos, you see many references delayering, particularly in the video describing the four layer Internet.

1
00:00:06.300 --> 00:00:12.580 
Layering is very, very widely used principle, and has been used in networking for decades, predating the Internet.

2
00:00:12.920 --> 00:00:17.660 
In fact, layering is a design principle used widely outside networking as well.

3
00:00:17.840 --> 00:00:19.590 
It's commonly used as a design principle in

4
00:00:19.800 --> 00:00:21.150 
many, many types of computer

5
00:00:21.320 --> 00:00:25.110 
system. There are lots of reasons for layering, and we'll explore some of them.

6
00:00:25.270 --> 00:00:28.750 
In this video. We'll explore what layering is.

7
00:00:28.910 --> 00:00:39.450 
We'll look at some of the simple examples of layering in communication and computer systems, and we'll explain why so many systems are led either by natural circumstance or deliberately by design.

8
00:00:40.390 --> 00:00:42.830 
Let's start with the definition of layering.

9
00:00:43.270 --> 00:00:50.040 
Layering is the name we give to the organization of a system into a number of separate functional components, or layers.

10
00:00:51.440 --> 00:00:55.860 
The layers are hierarchical, and they communicate sequentially words.

11
00:00:56.020 --> 00:00:59.880 
Each layer has an interface only to the layer directly above and below.

12
00:01:00.880 --> 00:01:09.740 
Each layer provides a well defined service to the layer above using the services provided by layers below and its own private processing.

13
00:01:10.980 --> 00:01:18.270 
There are many examples of layering in everyday life, particularly when one service is deliberately or naturally laid on top of another.

14
00:01:18.510 --> 00:01:25.790 
E.g., if you're looking for airplane tickets, you might visit a visit a brokerage website, such as Google Flights, hipmunk or Kayak.

15
00:01:26.640 --> 00:01:32.400 
These websites let you find tickets across a wide range of airlines by communicating with a single service.

16
00:01:32.680 --> 00:01:37.320 
You could instead go to the website of every airline to query what tickets they have available.

17
00:01:37.580 --> 00:01:44.980 
The brokerage website is providing you a service layer on top of each airline, abstracting away the details of each airline's website for you.

18
00:01:45.300 --> 00:01:51.100 
Now, if we look under the covers of each airline, they fly different types of airplane over different routes.

19
00:01:51.400 --> 00:01:59.120 
The airplane takes care of the details of providing the service, and offers you the simple abstraction of a ticket valid for a particular flight to take you between two airports.

20
00:01:59.560 --> 00:02:04.920 
The hiding many other details too, such as how they provide the, uh, the awful suit food they serve.

21
00:02:05.150 --> 00:02:09.950 
In many cases, they have a number of suppliers to provide meals, drinks, fuel and so on.

22
00:02:10.110 --> 00:02:12.850 
Each of those are naturally hidden from us, the consumer.

23
00:02:13.420 --> 00:02:23.580 
This separation of concerns allows each layer in the hierarchy to focus on doing its job well and provide a well defined service to the layer above.

24
00:02:26.060 --> 00:02:31.760 
Another well known example of layering closer to the Internet is the postal service.

25
00:02:32.440 --> 00:02:35.480 
Imagine that I have a book that I want to send to fill.

26
00:02:37.120 --> 00:02:44.690 
I place the book in an envelope, add fills address and mine, and then handed over to Olive to take to the mailbox.

27
00:02:45.690 --> 00:02:54.360 
The postal service sorts the mail, then sends it by a variety of different means airplanes, mail trucks, trains, etc.

28
00:02:54.740 --> 00:02:57.100 
Until it reaches a sorting office near Phil.

29
00:02:57.740 --> 00:03:02.980 
The mailman delivers the letter to Phil, who opens it and finds the book inside.

30
00:03:05.650 --> 00:03:09.230 
The service is clearly layed at the top.

31
00:03:09.390 --> 00:03:15.420 
I don't care how the letters get from me to fill, whether they go by airplane, truck or hovercraft.

32
00:03:15.720 --> 00:03:21.210 
And I don't care about the the route that the book takes or how many sorting offices it passes through along the way.

33
00:03:21.290 --> 00:03:25.130 
I don't mind whether Olive walk skips bicycles or runs to the mailbox.

34
00:03:25.320 --> 00:03:27.940 
I don't care which mail box she posts the lettering.

35
00:03:28.300 --> 00:03:35.360 
I want the lower layers to abstract away the details for me, provide, providing me with a simple service model.

36
00:03:35.360 --> 00:03:40.310 
I put the book in an envelope, and the layers below deliver it to fill in turn.

37
00:03:40.490 --> 00:03:43.110 
Olive doesn't need to know how the postal service delivers the letter.

38
00:03:43.490 --> 00:03:46.590 
She simply communicates with a layer below by posting the letter.

39
00:03:46.600 --> 00:03:53.960 
Phil just wants the book notice that each layer communicates only with the layers above and below.

40
00:03:54.060 --> 00:04:01.460 
If the postal service deploys new trains or starts using a different airline freight service, phil and I don't need to know about it.

41
00:04:01.650 --> 00:04:04.650 
In other words, because communication is simply up and down.

42
00:04:04.810 --> 00:04:09.990 
With a well defined interface between layers, we can improve each layer independently over time.

43
00:04:10.310 --> 00:04:17.190 
E.g., if I want faster, guaranteed delivery, I could handle the envelope to a carrier such as DHL or Fedex.

44
00:04:17.510 --> 00:04:19.290 
The interface is almost the same.

45
00:04:19.450 --> 00:04:25.950 
I simply give them an envelope and money layering is deliberately designed to many computer systems.

46
00:04:26.270 --> 00:04:29.230 
When we write programs, this is T-Y editing, a program.

47
00:04:29.390 --> 00:04:37.230 
We create source code using a language that abstracts away the details of the operating system, have virtual memory works, and have the low level details of the hardware.

48
00:04:37.270 --> 00:04:45.670 
Okay, so c is in great hiding the details, but many other languages, such as Java and Python, deliberately show us from how the lower layers.

49
00:04:46.560 --> 00:05:02.670 
As a programmer, we communicate with the layer below the compiler by handing at our source code, the compilers a self contained, functional component that was responsible for several tasks such as lexical analysis, parsing our code, pre processing declarations

50
00:05:02.830 --> 00:05:11.950 
and cogenerous generation. Is optimization. The compiler generates object code, which then it then passes to the linger.

51
00:05:12.340 --> 00:05:15.480 
The linker links together the compiled object files of libraries.

52
00:05:15.740 --> 00:05:22.000 
It generates an execuable file, the CPU real, a virtual then executes the coat.

53
00:05:22.960 --> 00:05:25.230 
If you have experience writing computer programs,

54
00:05:25.280 --> 00:05:26.940 
the benefits of layering are fairly

55
00:05:27.300 --> 00:05:41.460 
clear. In this example, larry breaks down the overall problem of writing programs that execute on hardware into modules or functional components, each with a well defined role and providing a well defined service to the layer above.

56
00:05:41.810 --> 00:05:45.770 
It also provides a clear separation of concerns.

57
00:05:45.810 --> 00:05:49.690 
The compiler can focus on lexical analysis, parsing and so on.

58
00:05:49.760 --> 00:05:52.920 
The linker can focus on efficiently piecing objects together.

59
00:05:53.240 --> 00:06:00.850 
Neither has to worry about the job of the other, and each can be improved, upgraded and replaced over time as technology and know how progresses.

60
00:06:01.130 --> 00:06:09.950 
E.g. we might swap out a commercial sea compiler with G-C-C, or vice versa, without needing to change the linker or the language we use.

61
00:06:13.680 --> 00:06:26.930 
When Nick 1st dropped to be slides, I was excited that he put compilers in as an example of layering, the great example of both the benefits of layering as well as how sometimes you need to break layering despite the very negative consequences.

62
00:06:27.970 --> 00:06:31.210 
So let's take the sea programming language as an example.

63
00:06:31.430 --> 00:06:34.960 
Generally speaking, a piece of sea code can be compelled for almost any processor.

64
00:06:35.120 --> 00:06:45.440 
We can take sea code, like this statement, I plus plus, and compel it for an arm processor and a phone, an x 8664 plus cern, a laptop, are micro controller and ultramotar dishwasher.

65
00:06:45.520 --> 00:06:50.520 
In this way, the sea code is hardware independent, and so it keeps the layer in here.

66
00:06:51.560 --> 00:06:57.970 
But sometimes we need our Seacoat to do something special that only our processor can do, e.g.

67
00:06:58.130 --> 00:07:04.470 
an XV six 64 processor has all kinds of special instructions that a micro controller doesn't see.

68
00:07:04.630 --> 00:07:08.090 
Allows you to include a suppli code directly.

69
00:07:08.330 --> 00:07:14.010 
Software like operating system kernels such as Linux and Windows uses for some of those lowests level implementations.

70
00:07:14.050 --> 00:07:21.690 
The layering that sea provides hides this detail, so it doesn't let you do so directly, but you have to do so to achieve your goal.

71
00:07:21.770 --> 00:07:26.210 
So Oyce kernels include assembly code doing so.

72
00:07:26.390 --> 00:07:36.710 
This means that the code is no longer layer independent the Linux context, which assembly written for Arm only works for Arm, so you have to write a version of this code for each layer.

73
00:07:37.090 --> 00:07:42.720 
If Linux wants to run in a new processor, developers need to write new assembly code for that processor.

74
00:07:43.400 --> 00:07:51.690 
So this is a great example, because they chose the benefits of layers that separate concerns in simplifier system, just as programming seas easier than assembly.

75
00:07:51.810 --> 00:07:55.170 
But sometimes you have to break the layer boundaries.

76
00:07:55.260 --> 00:07:57.380 
Doing so has a huge cost.

77
00:07:57.380 --> 00:08:01.900 
Suddenly you are no longer independent the lower layer, greatly limiting flexibility.

78
00:08:01.950 --> 00:08:07.670 
So sometimes you have to do it, but do so only when you really, really have to.

79
00:08:07.670 --> 00:08:17.520 
As we'll see, a lot of the practical operational challenges in the Internet today result from people breaking layering and assuming things above and below their service interface.

80
00:08:17.920 --> 00:08:25.500 
There's a continual tension to improve the Internet by making cross layer optimizations, and the resulting loss of flexibility.

81
00:08:26.540 --> 00:08:39.310 
We'll see. One really telling example of this was something called NATS, or NETWORKRA, Network address translators, tremendously useful devices that have, unfortunately made it almost impossible to add new transport particles to the Internet.

82
00:08:40.460 --> 00:08:45.100 
So in summary, there are five main reasons we use layering in computer systems.

83
00:08:46.020 --> 00:08:51.450 
Modularity. It breaks down the system into smaller, more manageable modules.

84
00:08:51.930 --> 00:08:56.530 
The well defined service. Each layer provides a well defined service to the layer above.

85
00:08:56.680 --> 00:09:03.420 
3rd reuse a layer above can rely on all the hard work put in by others to implement the layers below.

86
00:09:03.580 --> 00:09:07.390 
It saves us the time to write each layer whenever we build a new system.

87
00:09:07.950 --> 00:09:15.580 
4th separation of concerns. Each layer can focus on its own job without having to worry about how other layers do theirs.

88
00:09:15.740 --> 00:09:25.600 
The only communication is up and down the layers, so it helps keep one layers processing in data local an internal where possible, minimizing the complex interactions between layers.

89
00:09:25.640 --> 00:09:29.560 
5th it allows the a continuous improvement of each function.

90
00:09:30.990 --> 00:09:39.150 
6th 6th benefit is specific to lead communication systems such as the Internet, that is pier to peer communications.

91
00:09:39.270 --> 00:09:48.870 
In the four layer Internet model, we saw how well each layer communicates with its peer on another system, using the delivery service provided by it provided by the le layers below.

